# Generating Firefly Images with Class and Style Presets

At its simplest, the Firefly API can generate an image based on your prompt alone. However, there are numerous controls that can help improve and direct the final output to better represent what you need. In this tutorial, we will walk you through the process of how to direct Firefly to better create more appropriate results. 

## Prerequisites

In order to use this guide, you will need Firefly Services credentials, consisting of a `CLIENT_ID` and `CLIENT_SECRET` value. The code for this guide will make use of the [Firefly REST API](https://developer.adobe.com/firefly-services/docs/firefly-api/guides/api/upload_image/) via Node.js, but could be done in any language, or with the [SDK](https://developer.adobe.com/firefly-services/docs/guides/sdks/). The code demonstrated is using both imports and top level await so either save your sample as a `.mjs` file or use `"type":"module"` in your `package.json`. Let's get started.

## Specifying a Content Class

Images generated by Firefly fall into three general categories - photos, art, and vector. This is represented in the REST API as the parameter, `contentClass`. When you do not pass this value as part of your call, Firefly will do its best to guess what makes sense based on the prompt. However,  if you know what kind of result you want, it always makes sense to pass that in your code. To specify the value, simply add the `contentClass` key to your request body. For example:

```json
{
	"numVariations":1,
	"prompt":"The prompt here...",
	"contentClass":"art",
	"size":{
		"width":1792,
		"height":2304
	}
}
```

Let's see this in action by building a simple demo that shows the result of *not* specifying a class, and then selecting each of the three options. First, let's start with a few utility methods including authentication as well as downloading. This is pretty standardized so we won't cover it in detail.

```js
import fs from 'fs';
import { Readable } from 'stream';
import { finished } from 'stream/promises';

/*
Set our creds based on environment variables.
*/
const CLIENT_ID = process.env.CLIENT_ID;
const CLIENT_SECRET = process.env.CLIENT_SECRET;

async function getAccessToken(id, secret) {

	const params = new URLSearchParams();

	params.append('grant_type', 'client_credentials');
	params.append('client_id', id);
	params.append('client_secret', secret);
	params.append('scope', 'openid,AdobeID,firefly_enterprise,firefly_api,ff_apis');
	
	let resp = await fetch('https://ims-na1-stg1.adobelogin.com/ims/token/v3', 
		{ 
			method: 'POST', 
			body: params
		}
	);

	let data = await resp.json();
	return data.access_token;
}

async function downloadFile(url, filePath) {
	let res = await fetch(url);
	const body = Readable.fromWeb(res.body);
	const download_write_stream = fs.createWriteStream(filePath);
	return await finished(body.pipe(download_write_stream));
}
```

Now, let's write a generic function to use the [image generation](https://developer.adobe.com/firefly-services/docs/firefly-api/guides/api/image_generation/) features that allows for a prompt and optional content class:

```js
async function textToImage(prompt, id, token, contentClass) {

	let body = {
		numVariations:1,
		prompt,
		size:{
			width:1792,
			height:2304
		}
	}

	if(contentClass) body.contentClass = contentClass;

	let req = await fetch('https://firefly-api-enterprise-stage.adobe.io/v3/images/generate', {
		method:'POST',
		headers: {
			'X-Api-Key':id, 
			'Authorization':`Bearer ${token}`,
			'Content-Type':'application/json'
		}, 
		body: JSON.stringify(body)
	});

	return await req.json();
}
```

In this method, we've simply added `contentClass` as an argument, and if it exists, pass it along with the rest of the body to the API. This makes testing really easy.

First, get our access token and define a prompt:

```js
let token = await getAccessToken(CLIENT_ID, CLIENT_SECRET);

let prompt = 'A long-haired cat majestically riding a flying unicorn. The cat is wielding a rainbow shield and sword, pointing the swords tip outwards.';
```

Next, let's run four tests. First, specify no class and download the results:

```js
// First, no class
let result = await textToImage(prompt, CLIENT_ID, token);
let fileName = `./output/v3_noclass.jpg`;
await downloadFile(result.outputs[0].image.url, fileName);
```

Next, test all three options for content class:

```js
// Second, photo
result = await textToImage(prompt, CLIENT_ID, token, "photo");
fileName = `./output/v3_photo.jpg`;
await downloadFile(result.outputs[0].image.url, fileName);

// Third, art
result = await textToImage(prompt, CLIENT_ID, token, "art");
fileName = `./output/v3_art.jpg`;
await downloadFile(result.outputs[0].image.url, fileName);

// Lastly, vector
result = await textToImage(prompt, CLIENT_ID, token, "vector");
fileName = `./output/v3_vector.jpg`;
await downloadFile(result.outputs[0].image.url, fileName);
```

Given our prompt, "A long-haired cat majestically riding a flying unicorn. The cat is wielding a rainbow shield and sword, pointing the swords tip outwards.", here are the four results:

### No Content Class Specified

![No class](./v3_noclass.jpg)

### Photo Content Class

![Photo class](./v3_photo.jpg)

### Art Content Class

![Art](./v3_art.jpg)

### Vector Content Class

![Vector](./v3_vector.jpg)

## Specifying a Style Preset

Another way for Firefly to direct its output is via the use of [style presets](https://developer.adobe.com/firefly-services/docs/firefly-api/guides/concepts/styles/). These style presets are a *long* list of options ranging from black and white to "warm tone" and "misty". 

As with `contentClass` above, to specify a style preset, you simply include it in your request body:

```json
```json
{
	"numVariations":1,
	"prompt":"The prompt here...",
	"styleReference":{
		"presets":["bw","grainy_film"]
	},
	"size":{
		"width":1792,
		"height":2304
	}
}
```

In the above example, two presets are used, `bw`, for black and white, and `grainy_film` for a grainy film effect. In the [documentation](https://developer.adobe.com/firefly-services/docs/firefly-api/guides/concepts/styles/), you'll notice that each preset has a name and ID. For the API, you want to use the ID values only. 

Also note that while the `presets` value can be an array, Firefly will not "sanity" check these values. What that means is, if you intentionally ask Firefly to use presets that don't necessarily make sense, Firefly will try its best but the result may not be good. This is a case where artistic sense has to be applied, not developer skill. 

To test this, once again we build a simple utility method:

```js
async function textToImage(prompt, id, token, presets) {

	let body = {
		numVariations:1,
		prompt,
		size:{
			width:1792,
			height:2304
		}
	}

	if(presets) body.styleReference = { presets };

	let req = await fetch('https://firefly-api-enterprise-stage.adobe.io/v3/images/generate', {
		method:'POST',
		headers: {
			'X-Api-Key':id, 
			'Authorization':`Bearer ${token}`,
			'Content-Type':'application/json'
		}, 
		body: JSON.stringify(body)
	});

	return await req.json();
}
```

Once again, the method simply adds `presets` to the API call if passed. We can test like so:

```js
result = await textToImage(prompt, CLIENT_ID, token, ["golden"]);
fileName = `./output/v3_golden.jpg`;
await downloadFile(result.outputs[0].image.url, fileName);

result = await textToImage(prompt, CLIENT_ID, token, ["pastel_color"]);
fileName = `./output/v3_pastel_color.jpg`;
await downloadFile(result.outputs[0].image.url, fileName);
```

In the example above, we've used `golden` and `pastel_color`. Here are the results:

### Golden Result

![Golden result](./v3_golden.jpg)

### Pastel Colors Result

![Pastel Colors result](./v3_pastel_color.jpg)

## Next Steps

While we've now demonstrated two powerful ways to influence Firefly when generating images, there's still much more that can be tweaked in your code. Check the [API reference](https://bitter-tiger-28.redoc.ly/) for a full list of those options.
